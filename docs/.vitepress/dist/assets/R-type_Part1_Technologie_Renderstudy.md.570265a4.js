import{_ as e,c as t,o as n,a as r}from"./app.0d618599.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"\xC9tude Comparative Rendersystem","slug":"etude-comparative-rendersystem","link":"#etude-comparative-rendersystem","children":[]},{"level":3,"title":"Tableau Comparatif des Deux M\xE9thodes","slug":"tableau-comparatif-des-deux-methodes","link":"#tableau-comparatif-des-deux-methodes","children":[]},{"level":3,"title":"Conclusion","slug":"conclusion","link":"#conclusion","children":[]}],"relativePath":"R-type_Part1/Technologie/Renderstudy.md"}'),a={name:"R-type_Part1/Technologie/Renderstudy.md"},o=r('<h3 id="etude-comparative-rendersystem" tabindex="-1"><strong>\xC9tude Comparative Rendersystem</strong> <a class="header-anchor" href="#etude-comparative-rendersystem" aria-hidden="true">#</a></h3><p>Pour construire mon moteur de jeu, une d\xE9cision importante \xE9tait de savoir <strong>comment int\xE9grer une biblioth\xE8que externe comme SFML</strong>. Il y avait deux mani\xE8res de faire, chacune avec ses avantages et ses inconv\xE9nients.</p><h4 id="methode-a-l-integration-directe-la-voie-rapide" tabindex="-1"><strong>M\xE9thode A : L&#39;Int\xE9gration Directe (la voie rapide)</strong> <a class="header-anchor" href="#methode-a-l-integration-directe-la-voie-rapide" aria-hidden="true">#</a></h4><p>La premi\xE8re option \xE9tait d&#39;utiliser SFML directement partout dans mon code.</p><ul><li><strong>Comment \xE7a marche ?</strong> Mon syst\xE8me de rendu (<code>RenderSystem</code>) aurait directement appel\xE9 les fonctions de SFML. Le code aurait \xE9t\xE9 rempli de <code>fenetre_sfml.draw(...)</code>. C&#39;est comme construire une maison o\xF9 les murs, les fen\xEAtres et la plomberie sont tous de la m\xEAme marque et soud\xE9s ensemble.</li><li><strong>Avantages :</strong> C&#39;est plus rapide \xE0 mettre en place au d\xE9but.</li><li><strong>Inconv\xE9nients :</strong> Le moteur devient compl\xE8tement d\xE9pendant de SFML. Si je veux changer de &quot;marque&quot; de fen\xEAtres, je dois d\xE9molir tous les murs. Le code est moins organis\xE9.</li></ul><h4 id="methode-b-l-integration-par-abstraction-ma-methode" tabindex="-1"><strong>M\xE9thode B : L&#39;Int\xE9gration par Abstraction (ma m\xE9thode)</strong> <a class="header-anchor" href="#methode-b-l-integration-par-abstraction-ma-methode" aria-hidden="true">#</a></h4><p>J&#39;ai choisi une approche plus structur\xE9e en cr\xE9ant une &quot;couche d&#39;abstraction&quot;.</p><ul><li><strong>Comment \xE7a marche ?</strong> Mon moteur ne conna\xEEt pas SFML. Il conna\xEEt seulement un &quot;plan&quot; ou un &quot;contrat&quot; (<code>IGraphicsBackend</code>) qui d\xE9crit ce qu&#39;il a besoin de faire : &quot;dessiner un objet&quot;, &quot;ouvrir une fen\xEAtre&quot;. Ensuite, une pi\xE8ce sp\xE9cialis\xE9e (<code>SFMLBackend</code>) se charge de traduire ce plan en actions concr\xE8tes avec SFML. C&#39;est comme construire une maison avec des cadres de fen\xEAtre standards : n&#39;importe quelle marque de fen\xEAtre peut venir s&#39;y installer.</li><li><strong>Avantages :</strong> Le moteur est flexible et ind\xE9pendant. Le code est tr\xE8s bien organis\xE9.</li><li><strong>Inconv\xE9nients :</strong> Cela demande un peu plus de planification au d\xE9but.</li></ul><hr><h3 id="tableau-comparatif-des-deux-methodes" tabindex="-1"><strong>Tableau Comparatif des Deux M\xE9thodes</strong> <a class="header-anchor" href="#tableau-comparatif-des-deux-methodes" aria-hidden="true">#</a></h3><table><thead><tr><th style="text-align:left;">Crit\xE8re</th><th style="text-align:left;">M\xE9thode A (Utilisation Directe)</th><th style="text-align:left;">M\xE9thode B (Mon Choix : Abstraction)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Flexibilit\xE9</strong></td><td style="text-align:left;"><strong>Faible.</strong> Changer de biblioth\xE8que (passer de SFML \xE0 SDL) obligerait \xE0 r\xE9\xE9crire une grande partie du moteur. Le moteur est &quot;mari\xE9&quot; \xE0 SFML.</td><td style="text-align:left;"><strong>Tr\xE8s \xE9lev\xE9e.</strong> Je peux changer de biblioth\xE8que graphique juste en \xE9crivant un nouveau &quot;traducteur&quot; (<code>SDLBackend</code>), sans toucher au reste du moteur. C&#39;est un moteur &quot;pr\xEAt pour l&#39;avenir&quot;.</td></tr><tr><td style="text-align:left;"><strong>Organisation du Code</strong></td><td style="text-align:left;"><strong>Moyenne.</strong> La logique du jeu et la logique de l&#39;affichage sont m\xE9lang\xE9es. C&#39;est plus difficile de s&#39;y retrouver.</td><td style="text-align:left;"><strong>Excellente.</strong> Le code du jeu est compl\xE8tement s\xE9par\xE9 du code de l&#39;affichage. [cite_start]C&#39;est ce qu&#39;on appelle un bon <strong>d\xE9couplage</strong>, une pratique essentielle demand\xE9e par le projet[cite: 196].</td></tr><tr><td style="text-align:left;"><strong>Effort Initial</strong></td><td style="text-align:left;"><strong>Faible.</strong> C&#39;est la solution la plus rapide pour avoir quelque chose \xE0 l&#39;\xE9cran.</td><td style="text-align:left;"><strong>Moyen.</strong> Il faut prendre le temps de bien concevoir le &quot;contrat&quot; (l&#39;interface) au d\xE9part.</td></tr></tbody></table><h3 id="conclusion" tabindex="-1"><strong>Conclusion</strong> <a class="header-anchor" href="#conclusion" aria-hidden="true">#</a></h3><p>[cite_start]En comparant ces deux approches, j&#39;ai choisi la <strong>M\xE9thode B (l&#39;abstraction)</strong> car elle correspond aux exigences d&#39;un <strong>vrai moteur de jeu</strong>[cite: 23]. Bien qu&#39;elle demande un peu plus de travail au d\xE9part, elle offre une flexibilit\xE9 et une qualit\xE9 de code bien sup\xE9rieures. Ce choix rend mon moteur plus robuste, plus facile \xE0 maintenir et capable d&#39;\xE9voluer, ce qui \xE9tait un objectif central du projet.</p>',13),s=[o];function i(d,l,u,c,m,p){return n(),t("div",null,s)}const f=e(a,[["render",i]]);export{h as __pageData,f as default};
