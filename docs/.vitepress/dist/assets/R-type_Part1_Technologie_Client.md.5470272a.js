import{_ as t,c as e,o as s,a}from"./app.c58da356.js";const g=JSON.parse('{"title":"\xC9tude comparative \u2014 Architecture du client r\xE9seau","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. Objectif","slug":"_1-objectif","link":"#_1-objectif","children":[]},{"level":2,"title":"2. Architecture actuelle \u2014 Synth\xE8se","slug":"_2-architecture-actuelle-\u2014-synthese","link":"#_2-architecture-actuelle-\u2014-synthese","children":[]},{"level":2,"title":"3. Comparaison des choix techniques","slug":"_3-comparaison-des-choix-techniques","link":"#_3-comparaison-des-choix-techniques","children":[{"level":3,"title":"3.1 Architecture r\xE9seau : UDP/TCP via Boost.Asio","slug":"_3-1-architecture-reseau-udp-tcp-via-boost-asio","link":"#_3-1-architecture-reseau-udp-tcp-via-boost-asio","children":[]},{"level":3,"title":"3.2 Gestion des paquets : syst\xE8me custom vs formats standardis\xE9s","slug":"_3-2-gestion-des-paquets-systeme-custom-vs-formats-standardises","link":"#_3-2-gestion-des-paquets-systeme-custom-vs-formats-standardises","children":[]},{"level":3,"title":"3.3 Threading et mod\xE8le asynchrone","slug":"_3-3-threading-et-modele-asynchrone","link":"#_3-3-threading-et-modele-asynchrone","children":[]},{"level":3,"title":"3.4 Int\xE9gration avec le moteur de jeu (RTypeGame)","slug":"_3-4-integration-avec-le-moteur-de-jeu-rtypegame","link":"#_3-4-integration-avec-le-moteur-de-jeu-rtypegame","children":[]},{"level":3,"title":"3.5 Interface utilisateur et console","slug":"_3-5-interface-utilisateur-et-console","link":"#_3-5-interface-utilisateur-et-console","children":[]}]},{"level":2,"title":"4. \xC9valuation synth\xE9tique","slug":"_4-evaluation-synthetique","link":"#_4-evaluation-synthetique","children":[]},{"level":2,"title":"5. Bonnes pratiques recommand\xE9es","slug":"_5-bonnes-pratiques-recommandees","link":"#_5-bonnes-pratiques-recommandees","children":[]}],"relativePath":"R-type_Part1/Technologie/Client.md"}'),n={name:"R-type_Part1/Technologie/Client.md"},r=a(`<h1 id="etude-comparative-\u2014-architecture-du-client-reseau" tabindex="-1">\xC9tude comparative \u2014 Architecture du client r\xE9seau <a class="header-anchor" href="#etude-comparative-\u2014-architecture-du-client-reseau" aria-hidden="true">#</a></h1><h2 id="_1-objectif" tabindex="-1">1. Objectif <a class="header-anchor" href="#_1-objectif" aria-hidden="true">#</a></h2><p>L&#39;objectif de cette partie de la documentation est de mettre en \xE9vidence la pertinence des choix faits dans la partie Client, leurs avantages, limites et les opportunit\xE9s d&#39;\xE9volution.</p><hr><h2 id="_2-architecture-actuelle-\u2014-synthese" tabindex="-1">2. Architecture actuelle \u2014 Synth\xE8se <a class="header-anchor" href="#_2-architecture-actuelle-\u2014-synthese" aria-hidden="true">#</a></h2><table><thead><tr><th>Composant</th><th>R\xF4le</th><th>Technologie</th></tr></thead><tbody><tr><td><strong>ClientRoom</strong></td><td>G\xE8re la communication avec une <em>room</em> distante via UDP (envoi d&#39;inputs / r\xE9ception d&#39;\xE9tat).</td><td><code>boost::asio</code></td></tr><tr><td><strong>client/main.cpp</strong></td><td>Programme de test : initialise le client, envoie des commandes, g\xE8re les threads.</td><td>C++17</td></tr><tr><td><strong>PacketsManager / PacketsFactory</strong></td><td>Partag\xE9s avec le serveur, g\xE8rent la s\xE9rialisation/d\xE9s\xE9rialisation.</td><td>C++ binaire</td></tr><tr><td><strong>R\xE9seau</strong></td><td>UDP pour gameplay, TCP possible pour handshake / login.</td><td><code>boost::asio</code></td></tr><tr><td><strong>Thread model</strong></td><td><code>io_context</code> + thread d&#39;entr\xE9e console + callbacks async.</td><td><code>std::thread</code>, async I/O</td></tr></tbody></table><hr><h2 id="_3-comparaison-des-choix-techniques" tabindex="-1">3. Comparaison des choix techniques <a class="header-anchor" href="#_3-comparaison-des-choix-techniques" aria-hidden="true">#</a></h2><h3 id="_3-1-architecture-reseau-udp-tcp-via-boost-asio" tabindex="-1">3.1 Architecture r\xE9seau : UDP/TCP via Boost.Asio <a class="header-anchor" href="#_3-1-architecture-reseau-udp-tcp-via-boost-asio" aria-hidden="true">#</a></h3><table><thead><tr><th>Crit\xE8re</th><th>Impl\xE9mentation actuelle (<code>boost::asio</code>)</th><th>Alternatives modernes (ENet, WebSocket, gRPC)</th><th>Analyse</th></tr></thead><tbody><tr><td><strong>Performance</strong></td><td>Excellente, bas niveau, contr\xF4le total</td><td>ENet : tr\xE8s rapide, fiabilis\xE9 sur UDP</td><td>Tr\xE8s adapt\xE9e pour jeu temps r\xE9el</td></tr><tr><td><strong>Fiabilit\xE9</strong></td><td>UDP non fiable (\xE0 g\xE9rer manuellement)</td><td>ENet / RakNet fournissent fiabilit\xE9 int\xE9gr\xE9e</td><td>Risque de perte de paquets</td></tr><tr><td><strong>Complexit\xE9</strong></td><td>\xC9lev\xE9e (callbacks, buffer management)</td><td>WebSocket plus simple mais plus lent</td><td>Maintenance plus difficile</td></tr><tr><td><strong>Interop\xE9rabilit\xE9</strong></td><td>Compatible C++ uniquement</td><td>WebSocket / gRPC multiplateforme</td><td>Limit\xE9 pour client Web</td></tr></tbody></table><p><strong>Conclusion :</strong> Le choix <code>boost::asio</code> UDP est performant et pertinent pour un client de jeu C++ natif, mais des biblioth\xE8ques sp\xE9cialis\xE9es (ENet, RakNet) pourraient simplifier la gestion de la fiabilit\xE9 et des retransmissions.</p><hr><h3 id="_3-2-gestion-des-paquets-systeme-custom-vs-formats-standardises" tabindex="-1">3.2 Gestion des paquets : syst\xE8me custom vs formats standardis\xE9s <a class="header-anchor" href="#_3-2-gestion-des-paquets-systeme-custom-vs-formats-standardises" aria-hidden="true">#</a></h3><table><thead><tr><th>Crit\xE8re</th><th>PacketsManager / IPacket (actuel)</th><th>Protocol Buffers / FlatBuffers / JSON</th><th>Analyse</th></tr></thead><tbody><tr><td><strong>Performance</strong></td><td>Excellente, binaire compact</td><td>Tr\xE8s bonne pour Protobuf/FlatBuffers</td><td>Optimal pour le temps r\xE9el</td></tr><tr><td><strong>Interop\xE9rabilit\xE9</strong></td><td>Restreinte (format propri\xE9taire)</td><td>Multi-langage (C#, JS, etc.)</td><td>Complexit\xE9 c\xF4t\xE9 client non-C++</td></tr><tr><td><strong>\xC9volutivit\xE9</strong></td><td>Ajout manuel des paquets</td><td>G\xE9n\xE9ration auto via <code>.proto</code></td><td>Plus d&#39;entretien manuel</td></tr><tr><td><strong>Debuggabilit\xE9</strong></td><td>Donn\xE9es binaires difficiles \xE0 lire</td><td>Protobuf/JSON plus transparents</td><td>Moins pratique pour debug rapide</td></tr></tbody></table><p><strong>Conclusion :</strong> Le syst\xE8me custom est efficace, mais pour supporter d&#39;autres clients (Unity, Web), migrer vers <strong>Protobuf</strong> permettrait une compatibilit\xE9 multi-langage sans sacrifier la performance.</p><hr><h3 id="_3-3-threading-et-modele-asynchrone" tabindex="-1">3.3 Threading et mod\xE8le asynchrone <a class="header-anchor" href="#_3-3-threading-et-modele-asynchrone" aria-hidden="true">#</a></h3><table><thead><tr><th>Crit\xE8re</th><th>Actuel (<code>io_context</code> + threads manuels)</th><th>Moderne (coroutines / futures / async-await)</th><th>Analyse</th></tr></thead><tbody><tr><td><strong>Performance</strong></td><td>Excellente sur petit nombre de threads</td><td>Comparable, voire meilleure (moins de contention)</td><td>Correct</td></tr><tr><td><strong>Lisibilit\xE9</strong></td><td>Moyenne (callbacks imbriqu\xE9s)</td><td>Plus lisible avec <code>co_await</code> (C++20)</td><td>Maintenance lourde</td></tr><tr><td><strong>Gestion des erreurs</strong></td><td>Complexe (try-catch dispers\xE9s)</td><td>Simplifi\xE9e avec exceptions structur\xE9es</td><td>Code verbeux</td></tr></tbody></table><p><strong>Conclusion :</strong> Le threading actuel fonctionne, mais la modernisation vers <strong>coroutines (<code>co_spawn</code>)</strong> rendrait le code plus propre et plus lisible tout en conservant les performances.</p><hr><h3 id="_3-4-integration-avec-le-moteur-de-jeu-rtypegame" tabindex="-1">3.4 Int\xE9gration avec le moteur de jeu (<code>RTypeGame</code>) <a class="header-anchor" href="#_3-4-integration-avec-le-moteur-de-jeu-rtypegame" aria-hidden="true">#</a></h3><table><thead><tr><th>Crit\xE8re</th><th>Impl\xE9mentation actuelle</th><th>Approche moderne (event loop / ECS / job system)</th><th>Analyse</th></tr></thead><tbody><tr><td><strong>Couplage</strong></td><td>Direct : <code>ClientRoom</code> met \xE0 jour <code>RTypeGame</code></td><td>D\xE9coupl\xE9 via events / messages</td><td>Risque de d\xE9pendance forte</td></tr><tr><td><strong>Synchronisation</strong></td><td>Temps r\xE9el (callbacks \u2192 mise \xE0 jour imm\xE9diate)</td><td>File d&#39;\xE9v\xE9nements thread-safe</td><td>Risque de condition de course</td></tr><tr><td><strong>Extensibilit\xE9</strong></td><td>Moyenne</td><td>\xC9lev\xE9e si via events</td><td>\u2795 \xC0 am\xE9liorer pour modularit\xE9</td></tr></tbody></table><p><strong>Conclusion :</strong> Le couplage direct est simple pour un prototype, mais un <strong>bus d&#39;\xE9v\xE9nements</strong> ou un <strong>syst\xE8me ECS</strong> permettrait une meilleure s\xE9paration entre le r\xE9seau et la logique de jeu.</p><hr><h3 id="_3-5-interface-utilisateur-et-console" tabindex="-1">3.5 Interface utilisateur et console <a class="header-anchor" href="#_3-5-interface-utilisateur-et-console" aria-hidden="true">#</a></h3><table><thead><tr><th>Crit\xE8re</th><th>Console CLI actuelle</th><th>Interface graphique / moteur int\xE9gr\xE9</th><th>Analyse</th></tr></thead><tbody><tr><td><strong>Simplicit\xE9</strong></td><td>Tr\xE8s bonne pour le test</td><td>Complexe \xE0 int\xE9grer</td><td>Bon choix pour debugging</td></tr><tr><td><strong>Exp\xE9rience utilisateur</strong></td><td>Limit\xE9e (commandes manuelles)</td><td>Interface int\xE9gr\xE9e dans le jeu</td><td>Peu intuitive</td></tr><tr><td><strong>Tests automatis\xE9s</strong></td><td>Possible via scripts shell</td><td>Difficile en GUI</td><td>Pratique pour CI</td></tr></tbody></table><p><strong>Conclusion :</strong> La console est adapt\xE9e au d\xE9veloppement, mais une int\xE9gration future \xE0 l&#39;UI du jeu (overlay r\xE9seau) am\xE9liorerait l&#39;exp\xE9rience finale.</p><hr><h2 id="_4-evaluation-synthetique" tabindex="-1">4. \xC9valuation synth\xE9tique <a class="header-anchor" href="#_4-evaluation-synthetique" aria-hidden="true">#</a></h2><table><thead><tr><th>Domaine</th><th>Choix actuel</th><th>Pertinence</th><th>Recommandations</th></tr></thead><tbody><tr><td><strong>R\xE9seau</strong></td><td><code>boost::asio</code> UDP</td><td>Solide</td><td>Ajouter couche fiabilit\xE9 (ou passer \xE0 ENet)</td></tr><tr><td><strong>Paquets</strong></td><td>Custom binaire</td><td>Performant</td><td>Migrer vers Protobuf pour compatibilit\xE9</td></tr><tr><td><strong>Threading</strong></td><td><code>std::thread</code> + async</td><td>Lisibilit\xE9 moyenne</td><td>Migrer vers coroutines C++20</td></tr><tr><td><strong>Couplage jeu</strong></td><td>Direct avec <code>RTypeGame</code></td><td>Serr\xE9</td><td>Introduire bus d&#39;\xE9v\xE9nements</td></tr><tr><td><strong>Interface utilisateur</strong></td><td>CLI</td><td>Simple</td><td>Int\xE9grer \xE0 moteur de jeu plus tard</td></tr><tr><td><strong>Logs / debug</strong></td><td>Console directe</td><td>Minimal</td><td>Ajouter logger (<code>spdlog</code>)</td></tr><tr><td><strong>S\xE9curit\xE9</strong></td><td>Non mentionn\xE9e</td><td></td><td>Ajouter validation et timeout c\xF4t\xE9 client</td></tr></tbody></table><hr><h2 id="_5-bonnes-pratiques-recommandees" tabindex="-1">5. Bonnes pratiques recommand\xE9es <a class="header-anchor" href="#_5-bonnes-pratiques-recommandees" aria-hidden="true">#</a></h2><ol><li><p><strong>Utiliser des coroutines pour la r\xE9ception asynchrone :</strong></p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki vp-code-dark"><code><span class="line"><span style="color:#FFA657;">awaitable</span><span style="color:#C9D1D9;">&lt;</span><span style="color:#FF7B72;">void</span><span style="color:#C9D1D9;">&gt; </span><span style="color:#FFA657;">ClientRoom</span><span style="color:#C9D1D9;">::</span><span style="color:#D2A8FF;">RxLoop</span><span style="color:#C9D1D9;">() {</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#FFA657;">std</span><span style="color:#C9D1D9;">::array</span><span style="color:#FF7B72;">&lt;uint8_t</span><span style="color:#C9D1D9;">, </span><span style="color:#79C0FF;">1024</span><span style="color:#FF7B72;">&gt;</span><span style="color:#C9D1D9;"> buffer;</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#FF7B72;">for</span><span style="color:#C9D1D9;"> (;;) {</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#FF7B72;">auto</span><span style="color:#C9D1D9;"> [n, endpoint] </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">co_await</span><span style="color:#C9D1D9;"> socket.</span><span style="color:#D2A8FF;">async_receive_from</span><span style="color:#C9D1D9;">(buffer, _server_endpoint, use_awaitable);</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#D2A8FF;">handlePacket</span><span style="color:#C9D1D9;">(buffer, n);</span></span>
<span class="line"><span style="color:#C9D1D9;">    }</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre><pre class="shiki vp-code-light"><code><span class="line"><span style="color:#953800;">awaitable</span><span style="color:#24292F;">&lt;</span><span style="color:#CF222E;">void</span><span style="color:#24292F;">&gt; </span><span style="color:#953800;">ClientRoom</span><span style="color:#24292F;">::</span><span style="color:#8250DF;">RxLoop</span><span style="color:#24292F;">() {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">std</span><span style="color:#24292F;">::array</span><span style="color:#CF222E;">&lt;uint8_t</span><span style="color:#24292F;">, </span><span style="color:#0550AE;">1024</span><span style="color:#CF222E;">&gt;</span><span style="color:#24292F;"> buffer;</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">for</span><span style="color:#24292F;"> (;;) {</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#CF222E;">auto</span><span style="color:#24292F;"> [n, endpoint] </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">co_await</span><span style="color:#24292F;"> socket.</span><span style="color:#8250DF;">async_receive_from</span><span style="color:#24292F;">(buffer, _server_endpoint, use_awaitable);</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#8250DF;">handlePacket</span><span style="color:#24292F;">(buffer, n);</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ol>`,33),o=[r];function i(l,d,c,p,u,h){return s(),e("div",null,o)}const y=t(n,[["render",i]]);export{g as __pageData,y as default};
