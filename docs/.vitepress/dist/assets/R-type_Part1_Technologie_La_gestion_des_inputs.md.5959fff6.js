import{_ as e,c as t,o,a as s}from"./app.c58da356.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"\xC9tude Comparative Inputsystem","slug":"etude-comparative-inputsystem","link":"#etude-comparative-inputsystem","children":[]},{"level":3,"title":"Tableau Comparatif des Deux M\xE9thodes","slug":"tableau-comparatif-des-deux-methodes","link":"#tableau-comparatif-des-deux-methodes","children":[]},{"level":3,"title":"Conclusion","slug":"conclusion","link":"#conclusion","children":[]}],"relativePath":"R-type_Part1/Technologie/La_gestion_des_inputs.md"}'),n={name:"R-type_Part1/Technologie/La_gestion_des_inputs.md"},i=s('<h3 id="etude-comparative-inputsystem" tabindex="-1"><strong>\xC9tude Comparative Inputsystem</strong> <a class="header-anchor" href="#etude-comparative-inputsystem" aria-hidden="true">#</a></h3><p>Pour g\xE9rer les entr\xE9es du joueur, il existe principalement deux philosophies. Le choix entre les deux a un impact important sur la flexibilit\xE9 et la clart\xE9 du moteur.</p><h4 id="methode-a-l-approche-traditionnelle-centree-sur-les-actions" tabindex="-1"><strong>M\xE9thode A : L&#39;Approche Traditionnelle (centr\xE9e sur les actions)</strong> <a class="header-anchor" href="#methode-a-l-approche-traditionnelle-centree-sur-les-actions" aria-hidden="true">#</a></h4><p>C&#39;est la m\xE9thode la plus fr\xE9quente dans les tutoriels et beaucoup de moteurs de jeu.</p><ul><li><strong>Comment \xE7a marche ?</strong> On d\xE9finit d&#39;abord les actions dont le jeu a besoin (ex: <code>&quot;SAUTER&quot;</code>, <code>&quot;TIRER&quot;</code>). Ensuite, on vient &quot;attacher&quot; une ou plusieurs touches physiques \xE0 chacune de ces actions. Le code du jeu demande ensuite : &quot;Est-ce que l&#39;action <code>&quot;SAUTER&quot;</code> est activ\xE9e ?&quot;.</li><li><strong>Avantages :</strong> C&#39;est tr\xE8s direct et facile \xE0 comprendre du point de vue du gameplay.</li><li><strong>Inconv\xE9nients :</strong> La touche physique est un peu une &quot;donn\xE9e magique&quot; attach\xE9e \xE0 une action. Si on veut cr\xE9er un menu de configuration de touches complexe, o\xF9 l&#39;on doit lister toutes les touches possibles et voir \xE0 quelle action elles sont li\xE9es, cela devient compliqu\xE9. Le syst\xE8me n&#39;est pas vraiment con\xE7u pour penser en termes de &quot;touches&quot;.</li></ul><h4 id="methode-b-mon-approche-centree-sur-les-touches" tabindex="-1"><strong>M\xE9thode B : Mon Approche (centr\xE9e sur les touches)</strong> <a class="header-anchor" href="#methode-b-mon-approche-centree-sur-les-touches" aria-hidden="true">#</a></h4><p>J&#39;ai choisi une architecture qui inverse cette logique.</p><ul><li><strong>Comment \xE7a marche ?</strong> J&#39;ai d&#39;abord d\xE9fini un &quot;dictionnaire&quot; de toutes les touches qui peuvent exister (<code>enum class Key</code>). C&#39;est ma source de v\xE9rit\xE9 sur le mat\xE9riel. Mon moteur conna\xEEt donc l&#39;existence de <code>Key::A</code>, <code>Key::Space</code>, <code>Key::ArrowUp</code>, etc., ind\xE9pendamment de toute action. Ensuite, mes actions (<code>&quot;MOVE_UP&quot;</code>, <code>&quot;FIRE&quot;</code>) sont d\xE9finies comme des <strong>regroupements de ces touches</strong>.</li><li><strong>Avantages :</strong> Le syst\xE8me est beaucoup plus flexible et mieux structur\xE9.</li><li><strong>Inconv\xE9nients :</strong> Demande de d\xE9finir cette longue liste de touches au d\xE9but.</li></ul><hr><h3 id="tableau-comparatif-des-deux-methodes" tabindex="-1"><strong>Tableau Comparatif des Deux M\xE9thodes</strong> <a class="header-anchor" href="#tableau-comparatif-des-deux-methodes" aria-hidden="true">#</a></h3><table><thead><tr><th style="text-align:left;">Crit\xE8re</th><th style="text-align:left;">M\xE9thode A (Traditionnelle)</th><th style="text-align:left;">M\xE9thode B (Mon Choix : centr\xE9e sur les touches)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Clart\xE9 du Code</strong></td><td style="text-align:left;"><strong>Moyenne.</strong> La relation entre une touche et une action est souvent cach\xE9e dans le code qui fait le &quot;binding&quot;.</td><td style="text-align:left;"><strong>Excellente.</strong> La liste de toutes les touches possibles est d\xE9finie \xE0 un seul endroit (<code>InputEnums.hpp</code>). C&#39;est clair, centralis\xE9 et facile \xE0 maintenir.</td></tr><tr><td style="text-align:left;"><strong>Flexibilit\xE9</strong></td><td style="text-align:left;"><strong>Limit\xE9e.</strong> Difficile de faire des op\xE9rations sur les touches elles-m\xEAmes. Par exemple, &quot;d\xE9sactiver toutes les touches de lettres&quot; serait compliqu\xE9 \xE0 coder.</td><td style="text-align:left;"><strong>Totale.</strong> Puisque j&#39;ai une liste compl\xE8te des touches, je peux cr\xE9er n&#39;importe quelle logique complexe. Cr\xE9er un menu de configuration des touches devient trivial : il suffit de parcourir mon \xE9num\xE9ration de touches.</td></tr><tr><td style="text-align:left;"><strong>D\xE9couplage</strong></td><td style="text-align:left;"><strong>Bon.</strong> Le jeu ne d\xE9pend pas directement des touches.</td><td style="text-align:left;"><strong>Parfait.</strong> Le syst\xE8me fait une distinction tr\xE8s nette entre la <strong>couche mat\xE9rielle</strong> (la liste de toutes les touches possibles) et la <strong>couche logique</strong> (les actions du jeu). C&#39;est une architecture tr\xE8s propre.</td></tr><tr><td style="text-align:left;"><strong>Gestion des Conflits</strong></td><td style="text-align:left;"><strong>Manuelle.</strong> Le syst\xE8me ne peut pas savoir facilement si la m\xEAme touche a \xE9t\xE9 assign\xE9e \xE0 deux actions diff\xE9rentes.</td><td style="text-align:left;"><strong>Facile \xE0 automatiser.</strong> Je peux facilement \xE9crire une fonction qui v\xE9rifie si une touche de mon \xE9num\xE9ration est utilis\xE9e dans plus d&#39;une action.</td></tr></tbody></table><h3 id="conclusion" tabindex="-1"><strong>Conclusion</strong> <a class="header-anchor" href="#conclusion" aria-hidden="true">#</a></h3><p>Mon choix d&#39;une architecture &quot;centr\xE9e sur les touches&quot; n&#39;est pas anodin. Alors que l&#39;approche traditionnelle est plus rapide pour un petit prototype, elle montre ses limites dans un vrai projet de moteur de jeu.</p><p>Ma m\xE9thode est un choix d&#39;ing\xE9nierie qui privil\xE9gie la <strong>robustesse</strong> et la <strong>flexibilit\xE9 \xE0 long terme</strong>. Elle cr\xE9e une base de code plus saine, plus facile \xE0 maintenir et bien mieux pr\xE9par\xE9e \xE0 des fonctionnalit\xE9s avanc\xE9es comme la personnalisation compl\xE8te des contr\xF4les par le joueur. C&#39;est une approche plus professionnelle et plus proche de ce que l&#39;on attend d&#39;un moteur de jeu bien con\xE7u.</p>',14),r=[i];function a(u,l,d,c,p,h){return o(),t("div",null,r)}const f=e(n,[["render",a]]);export{g as __pageData,f as default};
