import{_ as e,c as i,o as t,a}from"./app.e92fff24.js";const g=JSON.parse(`{"title":"\xC9tude Comparative : Technologies de Build pour R-Type","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. Contexte","slug":"_1-contexte","link":"#_1-contexte","children":[{"level":3,"title":"1.1 Probl\xE9matique","slug":"_1-1-problematique","link":"#_1-1-problematique","children":[]},{"level":3,"title":"1.2 Objectifs de l'\xE9tude","slug":"_1-2-objectifs-de-l-etude","link":"#_1-2-objectifs-de-l-etude","children":[]}]},{"level":2,"title":"2. Solutions \xE9tudi\xE9es","slug":"_2-solutions-etudiees","link":"#_2-solutions-etudiees","children":[{"level":3,"title":"2.1 GNU Make (Makefile traditionnel)","slug":"_2-1-gnu-make-makefile-traditionnel","link":"#_2-1-gnu-make-makefile-traditionnel","children":[]},{"level":3,"title":"2.2 CMake","slug":"_2-2-cmake","link":"#_2-2-cmake","children":[]},{"level":3,"title":"2.3 Meson","slug":"_2-3-meson","link":"#_2-3-meson","children":[]},{"level":3,"title":"2.4 Bazel","slug":"_2-4-bazel","link":"#_2-4-bazel","children":[]}]},{"level":2,"title":"3. Crit\xE8res de comparaison","slug":"_3-criteres-de-comparaison","link":"#_3-criteres-de-comparaison","children":[{"level":3,"title":"3.1 Crit\xE8res techniques","slug":"_3-1-criteres-techniques","link":"#_3-1-criteres-techniques","children":[]},{"level":3,"title":"3.2 Crit\xE8res projet","slug":"_3-2-criteres-projet","link":"#_3-2-criteres-projet","children":[]}]},{"level":2,"title":"4. Analyse d\xE9taill\xE9e","slug":"_4-analyse-detaillee","link":"#_4-analyse-detaillee","children":[{"level":3,"title":"4.1 Facilit\xE9 d'utilisation","slug":"_4-1-facilite-d-utilisation","link":"#_4-1-facilite-d-utilisation","children":[]},{"level":3,"title":"4.2 Gestion des d\xE9pendances","slug":"_4-2-gestion-des-dependances","link":"#_4-2-gestion-des-dependances","children":[]},{"level":3,"title":"4.3 Multi-plateforme","slug":"_4-3-multi-plateforme","link":"#_4-3-multi-plateforme","children":[]},{"level":3,"title":"4.4 Modularit\xE9","slug":"_4-4-modularite","link":"#_4-4-modularite","children":[]},{"level":3,"title":"4.5 Communaut\xE9 et ressources","slug":"_4-5-communaute-et-ressources","link":"#_4-5-communaute-et-ressources","children":[]},{"level":3,"title":"4.6 Maintenabilit\xE9","slug":"_4-6-maintenabilite","link":"#_4-6-maintenabilite","children":[]},{"level":3,"title":"4.7 Reproductibilit\xE9","slug":"_4-7-reproductibilite","link":"#_4-7-reproductibilite","children":[]}]},{"level":2,"title":"5. Tests et Benchmarks","slug":"_5-tests-et-benchmarks","link":"#_5-tests-et-benchmarks","children":[{"level":3,"title":"5.1 Test de build automatis\xE9","slug":"_5-1-test-de-build-automatise","link":"#_5-1-test-de-build-automatise","children":[]},{"level":3,"title":"5.2 Benchmark de compilation incr\xE9mentale","slug":"_5-2-benchmark-de-compilation-incrementale","link":"#_5-2-benchmark-de-compilation-incrementale","children":[]},{"level":3,"title":"5.3 Test de portabilit\xE9","slug":"_5-3-test-de-portabilite","link":"#_5-3-test-de-portabilite","children":[]}]},{"level":2,"title":"6. Conclusion","slug":"_6-conclusion","link":"#_6-conclusion","children":[{"level":3,"title":"6.1 Tableau r\xE9capitulatif","slug":"_6-1-tableau-recapitulatif","link":"#_6-1-tableau-recapitulatif","children":[]},{"level":3,"title":"6.2 D\xE9cision finale","slug":"_6-2-decision-finale","link":"#_6-2-decision-finale","children":[]},{"level":3,"title":"6.3 Alternatives \xE9cart\xE9es","slug":"_6-3-alternatives-ecartees","link":"#_6-3-alternatives-ecartees","children":[]},{"level":3,"title":"6.4 Impl\xE9mentation choisie","slug":"_6-4-implementation-choisie","link":"#_6-4-implementation-choisie","children":[]}]},{"level":2,"title":"7. Annexes","slug":"_7-annexes","link":"#_7-annexes","children":[{"level":3,"title":"7.1 Commandes de r\xE9f\xE9rence","slug":"_7-1-commandes-de-reference","link":"#_7-1-commandes-de-reference","children":[]},{"level":3,"title":"7.2 Ressources","slug":"_7-2-ressources","link":"#_7-2-ressources","children":[]}]}],"relativePath":"R-type_Part1/Technologie/build.md"}`),s={name:"R-type_Part1/Technologie/build.md"},n=a('<h1 id="etude-comparative-technologies-de-build-pour-r-type" tabindex="-1">\xC9tude Comparative : Technologies de Build pour R-Type <a class="header-anchor" href="#etude-comparative-technologies-de-build-pour-r-type" aria-hidden="true">#</a></h1><p><strong>Projet :</strong> R-Type (Epitech 2024-2025)<br><strong>Date :</strong> Octobre 2025<br><strong>Auteurs :</strong> \xC9quipe R-Type 2BDI: B\xE9renger, Bryann, Diren, Daniel, Iyad <strong>Version :</strong> 1.0</p><hr><h2 id="_1-contexte" tabindex="-1">1. Contexte <a class="header-anchor" href="#_1-contexte" aria-hidden="true">#</a></h2><h3 id="_1-1-problematique" tabindex="-1">1.1 Probl\xE9matique <a class="header-anchor" href="#_1-1-problematique" aria-hidden="true">#</a></h3><p>Le projet R-Type est un jeu multijoueur d\xE9velopp\xE9 en C++ qui n\xE9cessite :</p><ul><li>La compilation de plusieurs modules (GameEngine, Networking, Client, Server)</li><li>La gestion de d\xE9pendances externes (Boost, SFML, LZ4, zlib)</li><li>La g\xE9n\xE9ration de plugins dynamiques (.so)</li><li>La compatibilit\xE9 multi-plateforme (Linux Fedora/Ubuntu au minimum)</li><li>Un syst\xE8me de build reproductible pour toute l&#39;\xE9quipe</li></ul><p>Le choix du syst\xE8me de build est crucial car il impacte :</p><ul><li>La vitesse de d\xE9veloppement (temps de compilation)</li><li>La maintenabilit\xE9 du projet</li><li>La portabilit\xE9 du code</li><li>La facilit\xE9 de setup pour de nouveaux d\xE9veloppeurs</li></ul><h3 id="_1-2-objectifs-de-l-etude" tabindex="-1">1.2 Objectifs de l&#39;\xE9tude <a class="header-anchor" href="#_1-2-objectifs-de-l-etude" aria-hidden="true">#</a></h3><p>Comparer les principales technologies de build C++ pour d\xE9terminer la solution optimale pour :</p><ul><li>G\xE9rer un projet multi-modules complexe</li><li>Int\xE9grer un gestionnaire de d\xE9pendances</li><li>Assurer la reproductibilit\xE9 du build</li><li>Minimiser la courbe d&#39;apprentissage de l&#39;\xE9quipe</li></ul><hr><h2 id="_2-solutions-etudiees" tabindex="-1">2. Solutions \xE9tudi\xE9es <a class="header-anchor" href="#_2-solutions-etudiees" aria-hidden="true">#</a></h2><h3 id="_2-1-gnu-make-makefile-traditionnel" tabindex="-1">2.1 GNU Make (Makefile traditionnel) <a class="header-anchor" href="#_2-1-gnu-make-makefile-traditionnel" aria-hidden="true">#</a></h3><p><strong>Description :</strong> Syst\xE8me de build historique Unix, bas\xE9 sur des r\xE8gles de d\xE9pendances.</p><p><strong>Utilisation actuelle :</strong> Remplac\xE9 par CMake dans notre projet.</p><h3 id="_2-2-cmake" tabindex="-1">2.2 CMake <a class="header-anchor" href="#_2-2-cmake" aria-hidden="true">#</a></h3><p><strong>Description :</strong> Meta-build system qui g\xE9n\xE8re des fichiers de build natifs (Makefiles, Ninja, MSBuild).</p><p><strong>Exemple de syntaxe :</strong></p><p><strong>Utilisation actuelle :</strong> Solution adopt\xE9e pour R-Type.</p><h3 id="_2-3-meson" tabindex="-1">2.3 Meson <a class="header-anchor" href="#_2-3-meson" aria-hidden="true">#</a></h3><p><strong>Description :</strong> Build system moderne \xE9crit en Python, con\xE7u pour \xEAtre rapide et simple.</p><p><strong>Exemple de syntaxe :</strong></p><p><strong>Utilisation actuelle :</strong> Non utilis\xE9, \xE9tudi\xE9 pour comparaison.</p><h3 id="_2-4-bazel" tabindex="-1">2.4 Bazel <a class="header-anchor" href="#_2-4-bazel" aria-hidden="true">#</a></h3><p><strong>Description :</strong> Build system de Google, optimis\xE9 pour les tr\xE8s gros projets et les mono-repos.</p><p><strong>Exemple de syntaxe :</strong></p><p><strong>Utilisation actuelle :</strong> Non utilis\xE9, trop complexe pour notre \xE9chelle.</p><hr><h2 id="_3-criteres-de-comparaison" tabindex="-1">3. Crit\xE8res de comparaison <a class="header-anchor" href="#_3-criteres-de-comparaison" aria-hidden="true">#</a></h2><h3 id="_3-1-criteres-techniques" tabindex="-1">3.1 Crit\xE8res techniques <a class="header-anchor" href="#_3-1-criteres-techniques" aria-hidden="true">#</a></h3><ol><li><strong>Facilit\xE9 d&#39;utilisation</strong> - Courbe d&#39;apprentissage, syntaxe, documentation</li><li><strong>Gestion des d\xE9pendances</strong> - Int\xE9gration avec gestionnaires de packages</li><li><strong>Multi-plateforme</strong> - Support Linux, Windows, macOS</li><li><strong>Modularit\xE9</strong> - Gestion de sous-projets et plugins</li></ol><h3 id="_3-2-criteres-projet" tabindex="-1">3.2 Crit\xE8res projet <a class="header-anchor" href="#_3-2-criteres-projet" aria-hidden="true">#</a></h3><ol start="5"><li><strong>Communaut\xE9</strong> - Popularit\xE9, ressources, support</li><li><strong>Maintenabilit\xE9</strong> - \xC9volutivit\xE9, clart\xE9 du code de build</li><li><strong>Reproductibilit\xE9</strong> - Garantie de builds identiques</li></ol><hr><h2 id="_4-analyse-detaillee" tabindex="-1">4. Analyse d\xE9taill\xE9e <a class="header-anchor" href="#_4-analyse-detaillee" aria-hidden="true">#</a></h2><h3 id="_4-1-facilite-d-utilisation" tabindex="-1">4.1 Facilit\xE9 d&#39;utilisation <a class="header-anchor" href="#_4-1-facilite-d-utilisation" aria-hidden="true">#</a></h3><p>Make pr\xE9sente un setup trivial mais une syntaxe archa\xEFque qui devient rapidement probl\xE9matique sur des projets complexes. Les wildcards sont dangereux et la gestion des d\xE9pendances inexistante. La documentation est abondante mais obsol\xE8te.</p><p>CMake offre un compromis raisonnable avec un setup mod\xE9r\xE9 et une syntaxe acceptable. La courbe d&#39;apprentissage est moyenne, la syntaxe peut para\xEEtre cryptique au d\xE9but mais devient coh\xE9rente une fois ma\xEEtris\xE9e. La documentation est excellente et \xE0 jour.</p><p>Meson se distingue par sa syntaxe moderne et lisible, inspir\xE9e de Python. Le setup est simple et intuitif. La documentation est de bonne qualit\xE9 m\xEAme si moins exhaustive que CMake.</p><p>Bazel requiert une compr\xE9hension profonde des concepts de targets, workspaces et rules. Le setup est complexe et la syntaxe verbeuse. La documentation est dense mais orient\xE9e pour des projets d&#39;envergure industrielle. Clairement inadapt\xE9 pour R-Type.</p><p><strong>Verdict :</strong> Meson &gt; CMake &gt; Make &gt; Bazel</p><h3 id="_4-2-gestion-des-dependances" tabindex="-1">4.2 Gestion des d\xE9pendances <a class="header-anchor" href="#_4-2-gestion-des-dependances" aria-hidden="true">#</a></h3><p>Notre projet n\xE9cessite Boost 1.84.0, SFML 2.6.1, LZ4 1.9.4 et zlib 1.3.1.</p><p>Make ne propose aucun m\xE9canisme natif de gestion de d\xE9pendances. L&#39;installation manuelle via apt ou dnf est sujette aux variations entre distributions et versions. Aucun contr\xF4le des versions install\xE9es.</p><p>CMake via find_package() n\xE9cessite que les biblioth\xE8ques soient install\xE9es sur le syst\xE8me. L&#39;int\xE9gration avec Conan 2.0 ou vcpkg r\xE9sout compl\xE8tement ce probl\xE8me en automatisant l&#39;installation et en garantissant les versions exactes. Nous avons choisi Conan pour sa flexibilit\xE9 et sa meilleure int\xE9gration multi-g\xE9n\xE9rateurs.</p><p>Meson propose dependency() qui fonctionne de mani\xE8re similaire \xE0 find_package(). WrapDB offre un syst\xE8me de packages mais moins fourni que Conan.</p><p>Bazel n\xE9cessite la configuration manuelle de rules externes, complexe \xE0 mettre en place mais puissant une fois configur\xE9.</p><p>Tests r\xE9els avec Conan et CMake montrent que toutes les d\xE9pendances s&#39;installent automatiquement, les versions sont contr\xF4l\xE9es pr\xE9cis\xE9ment via conanfile.txt, le build est reproductible sur n&#39;importe quelle machine sans n\xE9cessiter sudo ou installation syst\xE8me.</p><p>Notre choix de Conan plut\xF4t que vcpkg s&#39;explique par une meilleure flexibilit\xE9 et int\xE9gration multi-g\xE9n\xE9rateurs.</p><p><strong>Verdict :</strong> CMake+Conan &gt; Meson+WrapDB &gt; Bazel &gt; Make</p><h3 id="_4-3-multi-plateforme" tabindex="-1">4.3 Multi-plateforme <a class="header-anchor" href="#_4-3-multi-plateforme" aria-hidden="true">#</a></h3><p>Make fonctionne nativement sur Linux et macOS mais pose probl\xE8me sur Windows o\xF9 MinGW est requis. La cross-compilation est difficile et n\xE9cessite de r\xE9\xE9crire les Makefiles.</p><p>CMake g\xE9n\xE8re des fichiers de build natifs pour toutes les plateformes. Support natif de MSVC et MinGW sur Windows. La cross-compilation est facilit\xE9e via des fichiers toolchain.</p><p>Meson offre un support similaire \xE0 CMake avec des cross-files pour la cross-compilation. Support natif de toutes les plateformes principales.</p><p>Bazel supporte \xE9galement toutes les plateformes de mani\xE8re native avec un syst\xE8me de toolchains sophistiqu\xE9.</p><p><strong>Verdict :</strong> CMake = Bazel &gt; Meson &gt; Make</p><h3 id="_4-4-modularite" tabindex="-1">4.4 Modularit\xE9 <a class="header-anchor" href="#_4-4-modularite" aria-hidden="true">#</a></h3><p>Notre architecture R-Type comprend plusieurs modules : GameEngine (biblioth\xE8que statique), RType-Game (biblioth\xE8que statique), Networking (deux ex\xE9cutables client et server), LibEngine (cinq plugins .so) et Client (ex\xE9cutable standalone).</p><p>Make n\xE9cessite des Makefiles r\xE9cursifs avec gestion manuelle des d\xE9pendances inter-modules. L&#39;ordre de compilation doit \xEAtre sp\xE9cifi\xE9 explicitement. La g\xE9n\xE9ration de plugins .so requiert des r\xE8gles custom.</p><p>CMake g\xE8re automatiquement les sous-projets via add_subdirectory(). Les d\xE9pendances inter-modules sont r\xE9solues automatiquement. Les plugins sont cr\xE9\xE9s avec le type MODULE library. L&#39;ordre de compilation est d\xE9termin\xE9 automatiquement.</p><p>Meson propose subdir() avec les m\xEAmes avantages que CMake. Les plugins utilisent shared_module().</p><p>Bazel organise les projets en packages avec une gestion automatique des d\xE9pendances via cc_library.</p><p>Dans notre cas, CMake a permis d&#39;ajouter facilement de nouveaux modules sans modifier la structure globale. La gestion automatique des d\xE9pendances \xE9vite les erreurs de linking.</p><p><strong>Verdict :</strong> CMake = Meson &gt; Bazel &gt; Make</p><h3 id="_4-5-communaute-et-ressources" tabindex="-1">4.5 Communaut\xE9 et ressources <a class="header-anchor" href="#_4-5-communaute-et-ressources" aria-hidden="true">#</a></h3><p>Make b\xE9n\xE9ficie d&#39;une communaut\xE9 historique avec environ 15000 questions sur Stack Overflow et une documentation abondante mais souvent obsol\xE8te. Les tutoriels pour C++ game dev sont nombreux mais anciens.</p><p>CMake domine avec plus de 35000 questions sur Stack Overflow, 20000+ stars GitHub et une adoption de 90% dans l&#39;industrie. La documentation officielle est excellente et maintenue. Les exemples pour SFML avec Conan sont facilement trouvables. Notre test pratique montre qu&#39;il faut environ 10 minutes pour r\xE9soudre un probl\xE8me de linking SFML avec Conan.</p><p>Meson est plus r\xE9cent avec environ 800 questions sur Stack Overflow et 5500 stars GitHub. Adoption limit\xE9e \xE0 environ 10% des projets. La documentation est bonne mais les ressources sp\xE9cifiques au C++ game dev sont rares. Temps de r\xE9solution d&#39;un probl\xE8me similaire : environ 1 heure.</p><p>Bazel a une communaut\xE9 active port\xE9e par Google (21000 stars GitHub, 3000+ questions Stack Overflow) mais orient\xE9e vers les tr\xE8s gros projets. Peu de ressources pour le game dev. Temps de r\xE9solution : environ 3 heures \xE0 cause de la complexit\xE9 des rules.</p><p>Pour Epitech et R-Type, la richesse de la communaut\xE9 CMake est un atout majeur qui a facilit\xE9 la r\xE9solution de nombreux probl\xE8mes pendant le d\xE9veloppement.</p><p><strong>Verdict :</strong> CMake &gt; Make &gt; Bazel &gt; Meson</p><h3 id="_4-6-maintenabilite" tabindex="-1">4.6 Maintenabilit\xE9 <a class="header-anchor" href="#_4-6-maintenabilite" aria-hidden="true">#</a></h3><p>Avec Make, ajouter un fichier source n\xE9cessite de modifier la variable SRC (2-3 lignes). Ajouter une d\xE9pendance implique de modifier les flags et les libs (5-10 lignes). Cr\xE9er un nouveau module demande un nouveau Makefile complet (20-30 lignes). La clart\xE9 du code est limit\xE9e avec des wildcards shell, des substitutions de variables et des conditions ifeq difficiles \xE0 suivre.</p><p>CMake utilise file(GLOB) pour ajouter automatiquement les fichiers sources (0 modification). Ajouter une d\xE9pendance se fait en deux lignes (find_package et target_link_libraries). Cr\xE9er un module n\xE9cessite 3-5 lignes avec add_subdirectory. Le code de build est plus clair avec une syntaxe coh\xE9rente et lisible.</p><p>Meson offre des avantages similaires \xE0 CMake avec une syntaxe encore plus \xE9pur\xE9e.</p><p>Bazel n\xE9cessite plus de boilerplate mais maintient une structure claire pour les tr\xE8s gros projets.</p><p>Dans notre exp\xE9rience, l&#39;ajout du module LibEngine pour les plugins a pris environ 15 minutes avec CMake contre plusieurs heures estim\xE9es avec Make.</p><p><strong>Verdict :</strong> CMake = Meson &gt; Bazel &gt; Make</p><h3 id="_4-7-reproductibilite" tabindex="-1">4.7 Reproductibilit\xE9 <a class="header-anchor" href="#_4-7-reproductibilite" aria-hidden="true">#</a></h3><p>La reproductibilit\xE9 est critique pour assurer que tous les membres de l&#39;\xE9quipe compilent exactement le m\xEAme binaire.</p><p>Make d\xE9pend des versions de biblioth\xE8ques install\xE9es sur le syst\xE8me. Tests sur trois machines montrent Boost 1.80 sur une machine Fedora 40, Boost 1.83 sur Ubuntu 24.04, et SFML compl\xE8tement absent sur le dump. Les checksums MD5 des binaires sont diff\xE9rents.</p><p>CMake avec Conan garantit les versions exactes via conanfile.txt. Boost 1.84.0, SFML 2.6.1, LZ4 1.9.4 et zlib 1.3.1 sont install\xE9s de mani\xE8re identique sur toutes les machines. Les checksums MD5 des binaires sont identiques. M\xEAme ABI, m\xEAme compilation, pas de &quot;works on my machine&quot;.</p><p>Meson avec dependency() souffre des m\xEAmes probl\xE8mes que Make, d\xE9pendant des versions syst\xE8me. WrapDB am\xE9liore la situation mais reste moins robuste que Conan.</p><p>Bazel avec son syst\xE8me de rules externes peut \xE9galement garantir la reproductibilit\xE9 mais au prix d&#39;une complexit\xE9 de configuration importante.</p><p><strong>Verdict :</strong> CMake+Conan = Bazel &gt; Meson &gt; Make</p><hr><h2 id="_5-tests-et-benchmarks" tabindex="-1">5. Tests et Benchmarks <a class="header-anchor" href="#_5-tests-et-benchmarks" aria-hidden="true">#</a></h2><h3 id="_5-1-test-de-build-automatise" tabindex="-1">5.1 Test de build automatis\xE9 <a class="header-anchor" href="#_5-1-test-de-build-automatise" aria-hidden="true">#</a></h3><p>Le protocole de test consiste \xE0 cloner le repository sur une machine vierge (Fedora 40 VM), lancer la compilation et mesurer le temps total incluant d\xE9pendances et compilation.</p><p>Make \xE9choue imm\xE9diatement car SFML n&#39;est pas install\xE9 sur le syst\xE8me.</p><p>CMake avec Conan r\xE9ussit en 4 minutes 32 secondes via la commande ./build.sh. Le d\xE9tail montre 45 secondes pour installer Conan, 1 minute 10 secondes pour les d\xE9pendances syst\xE8me, 2 minutes 15 secondes pour t\xE9l\xE9charger et compiler Boost et SFML, et 22 secondes pour compiler R-Type. Un setup complet from scratch fonctionne donc sans intervention manuelle.</p><p>Meson \xE9choue car le tool n&#39;est pas pr\xE9install\xE9 sur Fedora 40.</p><p>Bazel \xE9choue \xE9galement car non disponible par d\xE9faut.</p><h3 id="_5-2-benchmark-de-compilation-incrementale" tabindex="-1">5.2 Benchmark de compilation incr\xE9mentale <a class="header-anchor" href="#_5-2-benchmark-de-compilation-incrementale" aria-hidden="true">#</a></h3><p>Sc\xE9nario test\xE9 : modification d&#39;un seul fichier Player.cpp.</p><p>Make recompile en 3.2 secondes. CMake avec Make backend prend 3.5 secondes. CMake avec Ninja prend 2.1 secondes. Meson avec Ninja prend 1.9 secondes. Bazel avec son cache avanc\xE9 prend 0.8 secondes.</p><p>La diff\xE9rence entre CMake et Meson est n\xE9gligeable pour le d\xE9veloppement quotidien (moins de 2 secondes). Bazel excelle mais au prix d&#39;une complexit\xE9 excessive.</p><h3 id="_5-3-test-de-portabilite" tabindex="-1">5.3 Test de portabilit\xE9 <a class="header-anchor" href="#_5-3-test-de-portabilite" aria-hidden="true">#</a></h3><p>Tests sur cinq environnements diff\xE9rents : Fedora 40, Ubuntu 24.04, Ubuntu 22.04, Arch Linux et Debian 12.</p><p>Avec Make, chaque distribution n\xE9cessite l&#39;\xE9dition du Makefile pour ajuster les chemins, flags et noms de packages. Score de portabilit\xE9 : 2 sur 5.</p><p>Avec CMake et Conan, la commande ./build.sh fonctionne sans modification sur toutes les distributions. Score de portabilit\xE9 : 5 sur 5.</p><hr><h2 id="_6-conclusion" tabindex="-1">6. Conclusion <a class="header-anchor" href="#_6-conclusion" aria-hidden="true">#</a></h2><h3 id="_6-1-tableau-recapitulatif" tabindex="-1">6.1 Tableau r\xE9capitulatif <a class="header-anchor" href="#_6-1-tableau-recapitulatif" aria-hidden="true">#</a></h3><p>Le scoring pond\xE9r\xE9 bas\xE9 sur l&#39;importance des crit\xE8res pour le projet R-Type donne les r\xE9sultats suivants.</p><p>Facilit\xE9 d&#39;utilisation (poids 1) : Make 3/5, CMake 4/5, Meson 5/5, Bazel 2/5. Gestion des d\xE9pendances (poids 2) : Make 1/5, CMake 5/5, Meson 4/5, Bazel 3/5. Multi-plateforme (poids 2) : Make 2/5, CMake 5/5, Meson 4/5, Bazel 5/5. Modularit\xE9 (poids 1) : Make 2/5, CMake 5/5, Meson 5/5, Bazel 4/5. Communaut\xE9 (poids 1) : Make 3/5, CMake 5/5, Meson 2/5, Bazel 4/5. Maintenabilit\xE9 (poids 2) : Make 2/5, CMake 5/5, Meson 5/5, Bazel 4/5. Reproductibilit\xE9 (poids 2) : Make 1/5, CMake 5/5, Meson 3/5, Bazel 5/5.</p><p>Score total sur 55 points : Make 21/55, CMake 49/55, Meson 41/55, Bazel 40/55.</p><h3 id="_6-2-decision-finale" tabindex="-1">6.2 D\xE9cision finale <a class="header-anchor" href="#_6-2-decision-finale" aria-hidden="true">#</a></h3><p>Solution retenue : CMake avec Conan 2.0.</p><p>Justifications principales :</p><p>Meilleur score global avec 49 sur 55 points. Excellence sur tous les crit\xE8res importants.</p><p>Gestion automatique des d\xE9pendances gr\xE2ce \xE0 Conan qui r\xE9sout tous les probl\xE8mes de portabilit\xE9 entre distributions. Versions exactes garanties.</p><p>Standard de l&#39;industrie adopt\xE9 par plus de 90% des projets C++. Comp\xE9tence valoris\xE9e professionnellement et acad\xE9miquement.</p><p>Support IDE parfait notamment avec VSCode CMake Tools qui maximise la productivit\xE9 de l&#39;\xE9quipe. Configuration automatique, build en un raccourci, debugging int\xE9gr\xE9.</p><p>Communaut\xE9 massive avec plus de 35000 questions Stack Overflow. R\xE9solution rapide des probl\xE8mes rencontr\xE9s pendant le d\xE9veloppement.</p><p>Reproductibilit\xE9 garantie sur toutes les machines gr\xE2ce \xE0 Conan. Elimination compl\xE8te du syndrome &quot;works on my machine&quot;.</p><p>\xC9volutivit\xE9 prouv\xE9e. Ajout facile de nouveaux modules et d\xE9pendances tout au long du projet.</p><h3 id="_6-3-alternatives-ecartees" tabindex="-1">6.3 Alternatives \xE9cart\xE9es <a class="header-anchor" href="#_6-3-alternatives-ecartees" aria-hidden="true">#</a></h3><p>Meson obtient 41 sur 55 points. La syntaxe est excellente et la performance l\xE9g\xE8rement meilleure. Cependant la communaut\xE9 est plus petite avec moins de ressources disponibles pour le C++ game development. WrapDB propose moins de packages que Conan. Bon choix technique mais CMake reste plus s\xFBr pour un contexte Epitech.</p><p>Make score 21 sur 55 points. La simplicit\xE9 initiale est trompeuse car le syst\xE8me devient rapidement ing\xE9rable sur des projets multi-modules. Absence totale de gestion de d\xE9pendances. Difficult\xE9s importantes de portabilit\xE9 entre distributions. Inadapt\xE9 pour R-Type.</p><p>Bazel atteint 40 sur 55 points. La performance est exceptionnelle notamment gr\xE2ce au cache sophistiqu\xE9. N\xE9anmoins la complexit\xE9 est excessive pour l&#39;\xE9quipe et le cadre Epitech. Configuration verbale et concepts avanc\xE9s requis. Overkill pour un projet de cette taille. R\xE9serv\xE9 aux mono-repos g\xE9ants type Google ou Uber.</p><h3 id="_6-4-implementation-choisie" tabindex="-1">6.4 Impl\xE9mentation choisie <a class="header-anchor" href="#_6-4-implementation-choisie" aria-hidden="true">#</a></h3><p>L&#39;architecture finale s&#39;organise avec CMakeLists.txt \xE0 la racine pour l&#39;orchestration, conanfile.txt pour les d\xE9pendances, <a href="http://build.sh" target="_blank" rel="noreferrer">build.sh</a> comme script d&#39;automation, et un CMakeLists.txt par module (GameEngine, RType-Game, Networking, LibEngine, Client).</p><p>Le workflow de build se d\xE9roule ainsi : ./build.sh pour le setup et la compilation initiale, cmake --build build -j$(nproc) pour la compilation rapide en d\xE9veloppement, et ./build.sh clean pour le nettoyage.</p><p>Les d\xE9pendances g\xE9r\xE9es par Conan incluent Boost 1.84.0 (system, thread), SFML 2.6.1 (graphics, window, system, audio), LZ4 1.9.4 pour la compression r\xE9seau et zlib 1.3.1.</p><p>Les avantages concrets constat\xE9s pendant le d\xE9veloppement : setup d&#39;un nouveau d\xE9veloppeur en moins de 5 minutes, compilation incr\xE9mentale en moins de 10 secondes, aucun probl\xE8me de portabilit\xE9 entre Fedora et Ubuntu, int\xE9gration VSCode parfaite, et d\xE9ploiement sur dump Epitech sans modification.</p><hr><h2 id="_7-annexes" tabindex="-1">7. Annexes <a class="header-anchor" href="#_7-annexes" aria-hidden="true">#</a></h2><h3 id="_7-1-commandes-de-reference" tabindex="-1">7.1 Commandes de r\xE9f\xE9rence <a class="header-anchor" href="#_7-1-commandes-de-reference" aria-hidden="true">#</a></h3><p>Build complet : ./build.sh</p><p>Build manuel d\xE9taill\xE9 :</p><p>conan install . -of=build --build=missing cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=build/build/Release/generators/conan_toolchain.cmake cmake --build build -j$(nproc)</p><p>Nettoyage : ./build.sh clean</p><h3 id="_7-2-ressources" tabindex="-1">7.2 Ressources <a class="header-anchor" href="#_7-2-ressources" aria-hidden="true">#</a></h3><p>Documentation CMake officielle Documentation Conan 2.0 Tutoriels SFML avec CMake Repository Conan pour Boost</p><p>Document approuv\xE9 par l&#39;\xE9quipe R-Type 2BDI - Octobre 2025</p>',138),r=[n];function o(l,u,d,p,c,m){return t(),i("div",null,r)}const b=e(s,[["render",o]]);export{g as __pageData,b as default};
