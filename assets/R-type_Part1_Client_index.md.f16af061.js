import{_ as e,c as o,o as i,a as t}from"./app.e92fff24.js";const m=JSON.parse(`{"title":"Client_Technique","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. Introduction","slug":"_1-introduction","link":"#_1-introduction","children":[]},{"level":2,"title":"2. Vue d'ensemble","slug":"_2-vue-d-ensemble","link":"#_2-vue-d-ensemble","children":[]},{"level":2,"title":"3. Points d'entr\xE9e","slug":"_3-points-d-entree","link":"#_3-points-d-entree","children":[]},{"level":2,"title":"4. ClientRoom (d\xE9tails)","slug":"_4-clientroom-details","link":"#_4-clientroom-details","children":[]},{"level":2,"title":"5. Protocole observ\xE9","slug":"_5-protocole-observe","link":"#_5-protocole-observe","children":[]},{"level":2,"title":"6. Concurrence & thread model","slug":"_6-concurrence-thread-model","link":"#_6-concurrence-thread-model","children":[]},{"level":2,"title":"7. Compilation (exemple)","slug":"_7-compilation-exemple","link":"#_7-compilation-exemple","children":[]}],"relativePath":"R-type_Part1/Client/index.md"}`),n={name:"R-type_Part1/Client/index.md"},l=t('<h1 id="client-technique" tabindex="-1">Client_Technique <a class="header-anchor" href="#client-technique" aria-hidden="true">#</a></h1><h2 id="_1-introduction" tabindex="-1">1. Introduction <a class="header-anchor" href="#_1-introduction" aria-hidden="true">#</a></h2><p>Document technique d\xE9crivant le client r\xE9seau (dans <code>Networking/Networking/client</code>) et l&#39;int\xE9gration au code RType.</p><h2 id="_2-vue-d-ensemble" tabindex="-1">2. Vue d&#39;ensemble <a class="header-anchor" href="#_2-vue-d-ensemble" aria-hidden="true">#</a></h2><p>Composants :</p><ul><li><code>ClientRoom</code> : abstraction client pour une room (communication UDP, envoi d&#39;inputs, r\xE9ception d&#39;\xE9tats).</li><li><code>client/main.cpp</code> : exemple d&#39;utilisation console / test harness.</li><li><code>PacketsManager</code> / <code>PacketsFactory</code> (partag\xE9) : s\xE9rialisation/d\xE9s\xE9rialisation.</li></ul><p>Le client utilise <code>boost::asio</code> (UDP pour la room, TCP possible pour login/handshake), et ex\xE9cute <code>io_context</code> dans un thread.</p><h2 id="_3-points-d-entree" tabindex="-1">3. Points d&#39;entr\xE9e <a class="header-anchor" href="#_3-points-d-entree" aria-hidden="true">#</a></h2><ul><li><code>client/main.cpp</code> : <ul><li>Init <code>boost::asio::io_context</code>.</li><li>Cr\xE9e un <code>ClientRoom</code> (passage host + port).</li><li>Lance un thread d&#39;entr\xE9e console qui lit des commandes (ex: <code>login</code>, <code>exit</code>).</li><li>Utilise <code>PacketsManager::buildPacket</code> pour construire les paquets, puis <code>async_write</code> (pour la partie TCP) ou <code>async_send_to</code> (UDP).</li></ul></li></ul><h2 id="_4-clientroom-details" tabindex="-1">4. ClientRoom (d\xE9tails) <a class="header-anchor" href="#_4-clientroom-details" aria-hidden="true">#</a></h2><ul><li>Construit un socket UDP li\xE9 \xE0 un endpoint local (<code>udp::endpoint(v4(), 0)</code>).</li><li>D\xE9finit <code>_server_endpoint</code> avec l&#39;adresse/port du serveur.</li><li>M\xE9thodes principales : <ul><li><code>Tx()</code> : envoi p\xE9riodique ou en r\xE9ponse d&#39;inputs (construit via <code>PacketsManager</code> puis <code>async_send_to</code>).</li><li><code>Rx()</code> : re\xE7oit donn\xE9es via <code>async_receive_from</code>, parse via <code>PacketsManager::parsePacket</code>.</li><li>Int\xE9gration \xE0 <code>RTypeGame</code> : l&#39;instance locale du jeu (<code>RTypeGame</code>) est tenue \xE0 jour avec les paquets <code>GameStatePacket</code> re\xE7us.</li></ul></li></ul><h2 id="_5-protocole-observe" tabindex="-1">5. Protocole observ\xE9 <a class="header-anchor" href="#_5-protocole-observe" aria-hidden="true">#</a></h2><ul><li>Handshake initial (probablement via TCP login) : <code>LoginPacket</code>.</li><li>Donn\xE9es de gameplay/inputs : <code>InputPacket</code> (envoi client \u2192 serveur).</li><li>R\xE9ception d&#39;\xE9tat : <code>GameStatePacket</code> (serveur \u2192 client), souvent en UDP pour latence r\xE9duite.</li></ul><h2 id="_6-concurrence-thread-model" tabindex="-1">6. Concurrence &amp; thread model <a class="header-anchor" href="#_6-concurrence-thread-model" aria-hidden="true">#</a></h2><ul><li><code>io_context</code> tourne dans un thread.</li><li>Thread d&#39;entr\xE9e console pour envoyer commandes manuelles.</li><li>Les callbacks asynchrones traitent la r\xE9ception et mettent \xE0 jour l&#39;\xE9tat de jeu.</li></ul><h2 id="_7-compilation-exemple" tabindex="-1">7. Compilation (exemple) <a class="header-anchor" href="#_7-compilation-exemple" aria-hidden="true">#</a></h2><p>Commande g\xE9n\xE9rique :</p>',17),a=[l];function c(d,r,s,u,p,h){return i(),o("div",null,a)}const v=e(n,[["render",c]]);export{m as __pageData,v as default};
