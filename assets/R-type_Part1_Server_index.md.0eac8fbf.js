import{_ as e,c as o,o as t,a as r}from"./app.419fa203.js";const g=JSON.parse('{"title":"Server_Technique","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. Introduction","slug":"_1-introduction","link":"#_1-introduction","children":[]},{"level":2,"title":"2. Vue d\u2019ensemble","slug":"_2-vue-d-ensemble","link":"#_2-vue-d-ensemble","children":[]},{"level":2,"title":"3. Points d\u2019entr\xE9e","slug":"_3-points-d-entree","link":"#_3-points-d-entree","children":[]},{"level":2,"title":"4. Composants principaux","slug":"_4-composants-principaux","link":"#_4-composants-principaux","children":[{"level":3,"title":"4.1 ServerHub","slug":"_4-1-serverhub","link":"#_4-1-serverhub","children":[]},{"level":3,"title":"4.2 RoomManager / Room / ServerRoom","slug":"_4-2-roommanager-room-serverroom","link":"#_4-2-roommanager-room-serverroom","children":[]},{"level":3,"title":"4.3 PacketsManager & PacketsFactory","slug":"_4-3-packetsmanager-packetsfactory","link":"#_4-3-packetsmanager-packetsfactory","children":[]}]},{"level":2,"title":"5. Protocole et paquets","slug":"_5-protocole-et-paquets","link":"#_5-protocole-et-paquets","children":[]},{"level":2,"title":"6. Concurrence et mod\xE8le de threads","slug":"_6-concurrence-et-modele-de-threads","link":"#_6-concurrence-et-modele-de-threads","children":[]},{"level":2,"title":"7. Logs et d\xE9bogage","slug":"_7-logs-et-debogage","link":"#_7-logs-et-debogage","children":[]},{"level":2,"title":"8. Compilation (exemple)","slug":"_8-compilation-exemple","link":"#_8-compilation-exemple","children":[]}],"relativePath":"R-type_Part1/Server/index.md"}'),a={name:"R-type_Part1/Server/index.md"},n=r('<h1 id="server-technique" tabindex="-1">Server_Technique <a class="header-anchor" href="#server-technique" aria-hidden="true">#</a></h1><h2 id="_1-introduction" tabindex="-1">1. Introduction <a class="header-anchor" href="#_1-introduction" aria-hidden="true">#</a></h2><p>Ce document d\xE9crit l\u2019architecture r\xE9seau et le fonctionnement interne du <strong>serveur</strong> fourni dans les archives (<code>Networking/Networking/server</code>).<br> Il s\u2019adresse \xE0 un public technique (d\xE9veloppeurs) souhaitant comprendre, maintenir ou \xE9tendre le serveur.</p><hr><h2 id="_2-vue-d-ensemble" tabindex="-1">2. Vue d\u2019ensemble <a class="header-anchor" href="#_2-vue-d-ensemble" aria-hidden="true">#</a></h2><p>Le serveur se compose principalement de :</p><ul><li><strong>ServerHub</strong> : point d\u2019entr\xE9e r\xE9seau (acceptation des connexions TCP).</li><li><strong>RoomManager / Room / ServerRoom</strong> : gestion des <em>rooms</em> (salles de jeu).<br> Les <em>rooms</em> orchestrent l\u2019\xE9tat du jeu et la communication (UDP/TCP selon les sous-syst\xE8mes).</li><li><strong>PacketsManager / PacketsFactory</strong> : s\xE9rialisation et d\xE9s\xE9rialisation des paquets applicatifs (login, room, input, gamestate\u2026).</li><li><strong>Utilitaires</strong> : <code>Signal</code> (\xE9v\xE9nements), <code>compress</code>, <code>encrypt</code> (optionnels / objets <code>.o</code> fournis).</li></ul><p>Le serveur utilise <code>boost::asio</code> pour l\u2019I/O r\xE9seau asynchrone et <code>std::thread</code> pour ex\xE9cuter l\u2019<code>io_context</code>.</p><hr><h2 id="_3-points-d-entree" tabindex="-1">3. Points d\u2019entr\xE9e <a class="header-anchor" href="#_3-points-d-entree" aria-hidden="true">#</a></h2><ul><li><strong><code>server/main.cpp</code></strong> : <ul><li>Cr\xE9e un <code>boost::asio::io_context</code>.</li><li>Instancie un <code>ServerHub</code>.</li><li>Lance <code>io_context::run()</code> dans un thread d\xE9di\xE9.</li><li>D\xE9marre le hub (<code>s.start()</code>), puis attend la terminaison.</li></ul></li></ul><hr><h2 id="_4-composants-principaux" tabindex="-1">4. Composants principaux <a class="header-anchor" href="#_4-composants-principaux" aria-hidden="true">#</a></h2><h3 id="_4-1-serverhub" tabindex="-1">4.1 ServerHub <a class="header-anchor" href="#_4-1-serverhub" aria-hidden="true">#</a></h3><ul><li><strong>R\xF4le</strong> : accepter les connexions TCP entrantes et relayer les messages vers le gestionnaire de <em>rooms</em>.</li><li><strong>Fonctionnalit\xE9s</strong> : <ul><li>Le constructeur initialise un <code>tcp::acceptor</code> sur le port sp\xE9cifi\xE9.</li><li><code>start()</code> : lance l\u2019acceptation asynchrone (<code>async_accept</code>) et la boucle d\u2019\xE9coute.</li><li><code>handleAccept()</code> : callback appel\xE9 lors d\u2019une nouvelle connexion.<br> Apr\xE8s acceptation, il d\xE9marre la lecture asynchrone et appelle la logique de parsing via <code>PacketsManager</code>.</li><li>Utilise des buffers internes (<code>std::array&lt;uint8_t, N&gt;</code>) et les fonctions <code>async_read_some</code> / <code>async_write</code>.</li></ul></li></ul><hr><h3 id="_4-2-roommanager-room-serverroom" tabindex="-1">4.2 RoomManager / Room / ServerRoom <a class="header-anchor" href="#_4-2-roommanager-room-serverroom" aria-hidden="true">#</a></h3><ul><li><strong>RoomManager</strong> : regroupe et administre plusieurs instances de <code>Room</code>.<br> Il g\xE8re la cr\xE9ation, la destruction et l\u2019assignation des clients aux rooms.</li><li><strong>Room</strong> : instance logique repr\xE9sentant une salle.<br> Elle conserve l\u2019\xE9tat du jeu (joueurs, entit\xE9s) et applique la logique du tick.</li><li><strong>ServerRoom</strong> : adaptation r\xE9seau de <code>Room</code>.<br> Elle envoie p\xE9riodiquement des <code>GameStatePacket</code> aux clients et applique les <code>InputPacket</code> re\xE7us.</li></ul><hr><h3 id="_4-3-packetsmanager-packetsfactory" tabindex="-1">4.3 PacketsManager &amp; PacketsFactory <a class="header-anchor" href="#_4-3-packetsmanager-packetsfactory" aria-hidden="true">#</a></h3><p>Ces classes assurent la gestion des paquets applicatifs :</p><ul><li><code>buildPacket(const IPacket&amp;)</code> \u2192 <code>std::vector&lt;uint8_t&gt;</code> : s\xE9rialisation binaire.</li><li><code>parsePacket(std::vector&lt;uint8_t&gt;&amp;)</code> \u2192 <code>std::unique_ptr&lt;IPacket&gt;</code> : d\xE9s\xE9rialisation.</li></ul><p><code>PacketsFactory</code> instancie dynamiquement les classes d\xE9riv\xE9es d\u2019<code>IPacket</code><br> (par exemple : <code>LoginPacket</code>, <code>InputPacket</code>, <code>GameStatePacket</code>).</p><hr><h2 id="_5-protocole-et-paquets" tabindex="-1">5. Protocole et paquets <a class="header-anchor" href="#_5-protocole-et-paquets" aria-hidden="true">#</a></h2><p>Les paquets d\xE9finis (dans <code>RType-Game/Packets</code>) couvrent les \xE9changes suivants :</p><ul><li><strong>LoginPacket</strong> : \xE9change d\u2019identifiants / m\xE9tadonn\xE9es (nom, id, version).</li><li><strong>InputPacket</strong> : entr\xE9es joueur (touches, directions).</li><li><strong>GameStatePacket</strong> : \xE9tat du monde (positions, entit\xE9s, points de vie).</li><li><strong>RoomPackets</strong> : cr\xE9ation / rejoindre une room, acknowledgment, etc.</li></ul><p>Chaque paquet impl\xE9mente l\u2019interface <code>IPacket</code> (type + s\xE9rialisation).<br><code>PacketsManager</code> g\xE8re l\u2019encodage binaire et la d\xE9tection du type \xE0 partir du flux.</p><hr><h2 id="_6-concurrence-et-modele-de-threads" tabindex="-1">6. Concurrence et mod\xE8le de threads <a class="header-anchor" href="#_6-concurrence-et-modele-de-threads" aria-hidden="true">#</a></h2><ul><li><code>boost::asio::io_context</code> est ex\xE9cut\xE9 dans un thread s\xE9par\xE9 (thread I/O).</li><li>Les <em>rooms</em> peuvent avoir leur propre thread de tick ou \xEAtre ex\xE9cut\xE9es depuis la boucle principale<br> (selon l\u2019impl\xE9mentation de <code>Room</code>).</li><li>Les acc\xE8s partag\xE9s (listes de clients, \xE9tat des rooms) doivent \xEAtre prot\xE9g\xE9s \xE0 l\u2019aide de <code>std::mutex</code> et <code>std::lock_guard</code>.<br> V\xE9rifier dans les fichiers <code>Room*.cpp</code> l\u2019utilisation appropri\xE9e de ces verrous.</li></ul><hr><h2 id="_7-logs-et-debogage" tabindex="-1">7. Logs et d\xE9bogage <a class="header-anchor" href="#_7-logs-et-debogage" aria-hidden="true">#</a></h2><ul><li>Le code utilise <code>std::cout</code> pour des journaux de base (connexion, lecture, erreurs).</li><li>Pour un usage en production, il est recommand\xE9 de remplacer cela par un logger (ex. : <code>spdlog</code>, <code>boost::log</code>)<br> avec des niveaux de log (<code>info</code>, <code>debug</code>, <code>error</code>).</li></ul><hr><h2 id="_8-compilation-exemple" tabindex="-1">8. Compilation (exemple) <a class="header-anchor" href="#_8-compilation-exemple" aria-hidden="true">#</a></h2><p><strong>Pr\xE9requis :</strong></p><ul><li>Compilateur C++ (<code>g++</code> ou <code>clang++</code>) compatible C++17 ou sup\xE9rieur.</li><li>Biblioth\xE8ques : <strong>Boost</strong> (<code>system</code>, <code>asio</code> \u2014 <em>header-only</em> possible) et <strong>pthread</strong>.</li></ul>',38),i=[n];function s(c,d,l,u,p,m){return t(),o("div",null,i)}const _=e(a,[["render",s]]);export{g as __pageData,_ as default};
